# KTH Ethical Hacking — CyberRange Design (draft)

Based on the given information regarding the Ethical Hacking Course at KTH, the system contains the following components and a brief explanation on how each component is used is given. 

1. **Google Cloud Platform (GCP):**
    - Hosts the course content and provides the infrastructure for the network.
    - VPN server enables students to access the course network securely.
    - Multiple worlds exist within GCP, each containing various VMs and challenges.
    - Honeypot server increases the number of systems visible to students.
2. **Ansible:**
    - Responsible for provisioning, recreating, restarting, and deleting VMs.
    - Each VM is configured with one or more vulnerabilities using Ansible roles.
3. **Scenario File:**
    - Defines the VMs and vulnerabilities within a world.
    - Generated dynamically based on configurable metrics and vulnerability metadata.
    - Used as the inventory file for Ansible.
4. **Educational Platform (Canvas LMS):**
    - Students can request hints for capturing flags.
    - Submits captured flags for grading.
    - Canvas LMS is fully automated using a "supervisor" service.
5. **Flag Management:**
    - Each vulnerability installs one or more flags for students to capture.
    - Flags can be text or image files.
    - Hints are provided in exchange for a lower grade.
    - Walkthrough videos generated automatically with script templates.
6. **Elasticsearch:**
    - Stores logs generated by Elastic beats agents monitoring student actions.
    - Resides in a separate monitoring network.
    - Enables data analysis, including student profiling and cheating detection.
7. **Machine Learning:**
    - Analyzes logs and student information to determine student behavior and cheating.
    - Uses Elasticsearch data to identify student actions preceding flag captures.
8. **Visualization Platform:**
    - Hosts visualizations and provides a live view of student actions and course status.
    - Displays active students, flags submitted, projected completion times, etc.
    - Generates a graph describing attack steps and hosts in the cyber range.
9. **Stack Overflow:**
    - Students ask course-related questions on Stack Overflow.
    - Recurring questions may be automated for handling.
10. **VM Management Service:**
    - Online service where students request VM restarts or restoration from snapshots.
    - Limited number of restarts/restores per day.
    - Supports live-testing of VMs using "hackscripts" to verify challenge functionality.
11. **Leak Detection:**
    - Scans the internet for leaks of course content on platforms like Pastebin.
    - Sends automatic alerts to Slack when a leak is detected.
12. **CLI App:**
    - Provides a command-line interface to manage various operations in the ecosystem.
    - Offers an easy and hierarchical abstraction of the system components.
    - Different CLI installations need to be synchronized regarding the cyber range state.
    - Learns about existing worlds, generated IP addresses, users/passwords, etc.
13. **Kubernetes Cluster:**
    - Hosts the CLI app and other services.
    - Provides accessibility to the CLI tool and additional course-related services.
    - Includes "Kali as a Service" for students to use during the course.
14. **Communication and Collaboration Tools:**
    - Email, Slack, and GitHub used for communication, notifications, and alerts.
    - Notifications about crucial events, such as downtime, are sent to these platforms.
15. **CI/CD and Automation:**
    - Jenkins and GitHub Actions used for continuous integration, deployment, and recurring tasks.
    - Performs leak scanning and other automated processes.

Now that we’ve seen the components used and and a brief explanation on their function, let’s take a look at a high level system design, on how the course labs/cyber range works.

```lua
+-----------------------------------+
|          Student Network          |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|           VPN Server              |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|       Google Cloud Platform       |
|                                   |
| +-----------------------------+   |
| |       World 1               |   |
| |                             |   |
| | +-------------------------+ |   |
| | |   VM 1                  | |   |
| | |                         | |   |
| | +-------------------------+ |   |
| |                             |   |
| | +-------------------------+ |   |
| | |   VM 2                  | |   |
| | |                         | |   |
| | +-------------------------+ |   |
| |                             |   |
| | +-------------------------+ |   |
| | |   Honeypot Server       | |   |
| | |                         | |   |
| | +-------------------------+ |   |
| +-----------------------------+   |
|                                   |
| +-----------------------------+   |
| |       World 2               |   |
| |                             |   |
| |         ...                 |   |
| +-----------------------------+   |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|           Ansible                 |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|        Scenario File              |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|        Canvas LMS                 |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|         Flag Management           |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|         Elastic Beats             |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|          Elasticsearch           |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|         Machine Learning          |
+-----------------------------------+
         |                 ^
         v                 |
+-----------------------------------+
|    Visualization Platform         |
+-----------------------------------+
```

Explanation flow for each (might be repetitive),

1. **Student Network:** Represents the network through which students access the course resources.
2. **VPN Server:** Provides secure access to the course network for students.
3. **Google Cloud Platform (GCP):** Hosts the course content, multiple worlds, and VMs for challenges. Includes separate VMs for the Honeypot server.
4. **Ansible:** Manages the provisioning, recreation, restarting, and deletion of VMs in the worlds.
5. **Scenario File:** Defines the VMs and vulnerabilities within each world. Used as an inventory file for Ansible.
6. **Canvas LMS:** Educational platform where students interact with the course. Students can submit flags, request hints, and access automated grading.
7. **Flag Management:** Manages the installation of vulnerabilities and flags on VMs. Provides hints and flag capture functionality.
8. **Elastic Beats:** Agents monitoring student actions in the network. Collects logs for analysis and monitoring.
9. **Elasticsearch:** Stores and indexes the logs generated by Elastic Beats. Used for data analysis, student profiling, and cheating detection.
10. **Machine Learning:** Analyzes Elasticsearch data to determine student behavior, feelings, and cheating. Contributes to student profiling.
11. **Visualization Platform:** Hosts visualizations and provides a live view of student actions and course status. Generates graphs describing attack steps and hosts in the cyber range.

From the design and components defined above we know that a scenario defined the VMs and vulnerabilities in each world. In simple words, scenario files breathe life into the worlds. An example scenario file for a command injection vulnerability is defined as follows(this is just a model on how the file looks and what should be present),

```json
{
  "world_name": "World 1",
  "theme": "Command Injection Vuln",
  "vms": [
    {
      "vm_name": "Injection Impossible",
      "vulnerabilities": [
        {
          "vulnerability_name": "Command Injection",
          "ansible_role": "command_injection",
          "flags": [
            {
              "flag_id": "flag_1",
              "description": "Capture the flag by injecting into the web app",
              "type": "text",
              "status": "uncaptured"
            }
          ],
          "hints": [
            {
              "hint_id": "hint_1",
              "description": "How to inspect inputs?",
              "video_url": "https://hints.com/hint_1",
              "grade_penalty": 2
            },
            {
              "hint_id": "hint_2",
              "description": "Focussing more on the vulnerable field",
              "video_url": "https://hints.com/hint_2",
              "grade_penalty": 1
            }
          ]
        }
      ]
    }
  ]
}
```

In this scenario file, we have a world named "World 1" with a theme focused on command injection challenges. Within the world, there is a single VM called "Injection Impossible" that hosts the command injection vulnerability.

The vulnerability is defined with the following details:

- Vulnerability Name: "Command Injection"
- Ansible Role: "command_injection" (referring to the specific Ansible role responsible for setting up the vulnerability)
- Flags: There is one flag defined with an ID, description, type (text), and status (uncaptured).
- Hints: Two hints are available for this vulnerability, each with an ID, description, video URL, and grade penalty associated with requesting the hint.

This scenario file provides the necessary information for provisioning the specific world, VM, vulnerability, and associated flags and hints related to the command injection challenge.

Now that we have an idea on how the system functions and what a scenario file looks like, let’s zoom in on the parts of the system that I consider to be the core. Yes there are multiple parts that I consider to be the core of the system. 

We can consider the world creation to be the core of the system because everything we interact with begins here, flag management and LMS integration can also be considered to be the cores as this an academic course and the cli app can also be considered as we are using that to interact and manage everything. 

Let’s start with **World Creation and Management,** 

```lua
+-----------------+              +-----------------+
|     World       |              |    Scenario     |
+-----------------+              +-----------------+
| - name: string  | 1          * | - world: World   |
| - theme: string | -------------| - vms: VM[]     |
| - vms: VM[]     |              +-----------------+
|                 |
| +create(): void |
| +delete(): void |
| +provision(): void |
+-----------------+

          ^
          |
          | 1          1
          |
+-----------------+
|       VM        |
+-----------------+
| - name: string  |
| - vulnerabilities: Vulnerability[] |
| - flags: Flag[] |
| - hints: Hint[] |
+-----------------+
|                 |
| +addVulnerability(vulnerability: Vulnerability): void |
| +removeVulnerability(vulnerability: Vulnerability): void |
+-----------------+

          ^
          |
          | *          1
          |
+-------------------+
|   Vulnerability   |
+-------------------+
| - name: string    |
| - ansibleRole: string |
| - preConditions: string |
| - postConditions: string |
+-------------------+

          ^
          |
          | *          1
          |
+---------------+
|     Flag      |
+---------------+
| - id: string  |
| - description: string |
| - type: string |
| - status: string |
+---------------+

          ^
          |
          | *          1
          |
+---------------+
|     Hint      |
+---------------+
| - id: string  |
| - description: string |
| - videoUrl: string |
| - gradePenalty: int |
+---------------+
```

In this UML class diagram, we have four main classes: **`World`**, **`VM`**, **`Vulnerability`**, and **`Flag`**. The **`World`** class represents a world in the Ethical Hacking course, which includes a name, theme, and a list of associated VMs. The **`World`** class has methods for creating, deleting, and provisioning the world.

The **`VM`** class represents a virtual machine within a world and contains properties such as name, vulnerabilities, flags, and hints. It has methods to add and remove vulnerabilities associated with the VM.

The **`Vulnerability`** class represents a specific vulnerability that can be associated with a VM. It includes properties such as name, Ansible role, pre-conditions, and post-conditions.

The **`Flag`** class represents a flag that the students need to capture. It includes properties such as an ID, description, type, and status.

Additionally, we have the **`Hint`** class, which represents a hint associated with a vulnerability. It contains properties such as an ID, description, video URL, and grade penalty.

This UML diagram provides an abstraction of the entities and relationships involved in the functionality of world creation and its associated components. This is simplified for ease of creation and to focus on the classes and their relationships. 

Now let us look at the **CLI APP and related stuff**

```lua
+-----------------+              +-----------------+
|     CLIApp      |              |    World        |
+-----------------+              +-----------------+
|                 |              | - name: string  |
| - cyberRange: CyberRange       | - theme: string |
|                 |              | - vms: VM[]     |
+-----------------+              |                 |
| +createWorld(): void           | +create(): void |
| +deleteWorld(): void           | +delete(): void |
| +provisionWorld(): void        | +provision(): void |
+-----------------+              +-----------------+
          |                              ^
          |                              |
          |1                             |1
          |                              |
          |                              |
          |                              |
+-----------------+              +-----------------+
|   CyberRange    |              |        VM       |
+-----------------+              +-----------------+
| - worlds: World[]               | - name: string  |
|                               * | - vulnerabilities: Vulnerability[] |
+-----------------+              +-----------------+
| +addWorld(world: World): void   |                 |
| +removeWorld(world: World): void| +addVulnerability(vulnerability: Vulnerability): void |
+-----------------+              | +removeVulnerability(vulnerability: Vulnerability): void |
                                 +-----------------+
                                          ^
                                          |
                                          |*                1
                                          |                 |
                                +-------------------+     |
                                |   Vulnerability   |     |
                                +-------------------+     |
                                | - name: string    |     |
                                | - ansibleRole: string | |
                                | - preConditions: string |
                                | - postConditions: string |
                                +-------------------+
```

In this UML class diagram, we have added the **`CLIApp`** and **`CyberRange`** classes to represent the CLI application and the cyber range respectively. The **`CLIApp`** class contains methods for creating, deleting, and provisioning worlds within the cyber range. The **`CyberRange`** class manages a collection of worlds.

The **`World`** class represents a world within the cyber range, including properties such as name, theme, and a list of associated VMs. It has methods for creating, deleting, and provisioning the world.

The **`VM`** class represents a virtual machine within a world and includes properties such as name and a list of associated vulnerabilities. It has methods for adding and removing vulnerabilities associated with the VM.

The **`Vulnerability`** class represents a specific vulnerability that can be associated with a VM. It includes properties such as name, Ansible role, pre-conditions, and post-conditions.

Finally coming to part where the grades are decided (**Flags and LMS**),

```lua
+---------------------+     +------------------+
|       Flag          |     |       Hint       |
+---------------------+     +------------------+
| -id: string         |     | -id: string      |
| -description: string|     | -description: string |
| -type: FlagType     |     | -videoUrl: string   |
| -status: FlagStatus |     | -gradePenalty: int  |
+---------------------+     +------------------+
          ^
          |
          |                        +--------------------+
          |                        |    CanvasLMS      |
          |                        +--------------------+
          |                        | +submitFlag(flag: Flag) |
          |                        +--------------------+
          |                                  ^
          v                                  |
+----------------------+                     |
|       Student        |                     |
+----------------------+                     |
| -id: string          |                     |
| -name: string        |                     |
| -email: string       |                     |
+----------------------+                     |
| +captureFlag(flag: Flag): void  ---------> |
+----------------------+                     |
```

In the above UML diagram, the classes "Flag," "Hint," "CanvasLMS," and "Student" are represented. The **`Flag`** class encapsulates the attributes of a flag, such as its ID, description, type (text or image), and status (captured or not). The **`Hint`** class includes attributes like the hint's ID, description, video URL (if available), and grade penalty for accessing the hint.

The **`CanvasLMS`** class represents the integration with the Canvas Learning Management System. It provides a method **`submitFlag(flag: Flag)`** for students to submit the captured flag for grading.

The **`Student`** class represents a student participating in the course. It has attributes such as student ID, name, and email. The **`Student`** class also has a method **`captureFlag(flag: Flag)`** that allows students to capture a flag during their course activities.

The system design combined with the UML diagrams gives us a rough starting point for us to start working on building the system.